import json
import os
import urllib.request
import boto3

def _j(obj):
    return json.dumps(obj, default=str)

def _try_json(x):
    if isinstance(x, str):
        try:
            return json.loads(x)
        except Exception:
            return x
    return x

def _resp(req, result=None, error=None):
    base = {"jsonrpc": "2.0", "id": None}
    if isinstance(req, dict):
        base["jsonrpc"] = req.get("jsonrpc", "2.0")
        base["id"] = req.get("id")
    if error is None:
        base["result"] = result
    else:
        base["error"] = error
    return base

def _infer_method(evt: dict):
    if "tools" in evt and isinstance(evt.get("tools"), list):
        return "tools/list"
    # If it looks like only tool args, treat as tools/call for single-tool target
    if "amount" in evt or "reason" in evt:
        return "tools/call"
    if ("name" in evt) or ("toolName" in evt) or ("tool" in evt):
        return "tools/call"
    return None

def _extract_req_method_params(event):
    evt = _try_json(event)
    if not isinstance(evt, dict):
        return {}, None, {}

    method = evt.get("method")
    params = _try_json(evt.get("params"))

    if not method:
        method = _infer_method(evt)

    # If params missing, treat whole event as params (your gateway does this)
    if params is None:
        params = evt

    if not isinstance(params, dict):
        params = {}

    return evt, method, params

def _extract_tool_name(params):
    if not isinstance(params, dict):
        return None
    name = params.get("name") or params.get("toolName")
    if name:
        return name
    tool = params.get("tool")
    if isinstance(tool, dict):
        return tool.get("name") or tool.get("toolName")
    nested = params.get("params")
    if isinstance(nested, dict):
        return _extract_tool_name(nested)
    return None

def _extract_tool_input(params):
    if not isinstance(params, dict):
        return {}

    args = params.get("arguments")
    if args is None:
        args = params.get("input")

    if args is None and isinstance(params.get("tool"), dict):
        t = params["tool"]
        args = t.get("arguments") or t.get("input")

    if args is None and isinstance(params.get("params"), dict):
        return _extract_tool_input(params["params"])

    args = _try_json(args)
    if args is None:
        args = {}
    if not isinstance(args, dict):
        args = {}
    return args

def _is_refund_tool(name: str) -> bool:
    return bool(name) and (name == "process_refund" or name.endswith("__process_refund"))

# ---------- Identity helpers ----------
def _get_identity_api_key():
    workload_name = os.environ["WORKLOAD_NAME"]
    provider_name = os.environ["RESOURCE_CREDENTIAL_PROVIDER_NAME"]

    dp = boto3.client("bedrock-agentcore")
    tok = dp.get_workload_access_token(workloadName=workload_name)
    wat = tok["workloadAccessToken"]

    key_resp = dp.get_resource_api_key(
        workloadIdentityToken=wat,
        resourceCredentialProviderName=provider_name
    )
    api_key = key_resp.get("apiKey") or key_resp.get("value")
    if not api_key:
        raise RuntimeError(f"API key not found in response: {key_resp}")
    return api_key

def _call_httpbin_headers(api_key: str):
    req = urllib.request.Request(
        "https://httpbin.org/headers",
        headers={"x-api-key": api_key, "user-agent": "agentcore-identity-e2e"},
        method="GET",
    )
    with urllib.request.urlopen(req, timeout=30) as resp:
        body = resp.read().decode("utf-8")
        return json.loads(body)

# ---------- Lambda handler ----------
def lambda_handler(event, context):
    print("=== RAW EVENT ===")
    print(_j(event))

    req, method, params = _extract_req_method_params(event)

    print("=== PARSED ===")
    print("method:", method)
    print("params:", _j(params))

    # tools/list
    if method == "tools/list":
        return _resp(req, result={
            "tools": [
                {
                    "name": "process_refund",
                    "description": "Process a refund request (and prove AgentCore Identity -> external API auth).",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "amount": {"type": "integer"},
                            "reason": {"type": "string"}
                        },
                        "required": ["amount", "reason"]
                    }
                }
            ]
        })

    # tools/call
    if method == "tools/call":
        tool_name = _extract_tool_name(params)
        tool_input = _extract_tool_input(params)

        # âœ… IMPORTANT FIX:
        # If gateway sends bare args like {"amount":25,"reason":"x"}, treat params as input.
        if (not tool_input) and isinstance(params, dict) and ("amount" in params or "reason" in params):
            tool_input = {k: params.get(k) for k in ["amount", "reason"] if k in params}

        # If tool_name is missing, assume single-tool target is refund
        if not tool_name:
            tool_name = "process_refund"

        print("tool_name:", tool_name)
        print("tool_input:", _j(tool_input))

        if not _is_refund_tool(tool_name) and tool_name != "process_refund":
            return _resp(req, error={"code": -32601, "message": f"Unknown tool: {tool_name}"})

        amount = tool_input.get("amount")
        reason = tool_input.get("reason")
        if amount is None or reason is None:
            return _resp(req, error={
                "code": -32602,
                "message": "Missing required fields (amount, reason)",
                "seen": {"tool_name": tool_name, "tool_input": tool_input, "params": params}
            })

        # Identity -> external API proof
        try:
            api_key = _get_identity_api_key()
            httpbin = _call_httpbin_headers(api_key)
            echoed = (httpbin.get("headers") or {}).get("X-Api-Key")
        except Exception as e:
            return _resp(req, error={"code": -32000, "message": f"Identity/external call failed: {str(e)}"})

        return _resp(req, result={
            "content": [
                {
                    "type": "text",
                    "text": json.dumps({
                        "status": "OK",
                        "amount": amount,
                        "reason": reason,
                        "message": "Refund processed",
                        "identity_proof": {
                            "echoed_x_api_key_from_httpbin": echoed,
                            "httpbin_headers_sample": httpbin.get("headers", {})
                        }
                    })
                }
            ]
        })

    return _resp(req, error={"code": -32601, "message": f"Unknown method: {method}"})
