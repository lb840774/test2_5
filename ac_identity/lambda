import os
import json
import boto3

REGION = os.environ.get("AWS_REGION", "us-east-1")
WORKLOAD_NAME = os.environ.get("WORKLOAD_NAME")  # required
APIKEY_PROVIDER_NAME = os.environ.get("APIKEY_PROVIDER_NAME")  # required

dp = boto3.client("bedrock-agentcore", region_name=REGION)

def _j(obj):
    return json.dumps(obj, default=str)

def _try_json(x):
    if isinstance(x, str):
        try:
            return json.loads(x)
        except Exception:
            return x
    return x

def _resp(req, result=None, error=None):
    base = {"jsonrpc": "2.0", "id": None}
    if isinstance(req, dict):
        base["jsonrpc"] = req.get("jsonrpc", "2.0")
        base["id"] = req.get("id")
    if error is None:
        base["result"] = result
    else:
        base["error"] = error
    return base

def _extract_req(event):
    """
    Supports:
    - JSON-RPC: {"jsonrpc":"2.0","id":1,"method":"tools/call","params":{...}}
    - Flattened: {"amount":25,"reason":"x"} (assume tools/call)
    """
    evt = _try_json(event)
    if not isinstance(evt, dict):
        return {}, None, {}

    method = evt.get("method")
    params = evt.get("params")

    # if it's not JSON-RPC style, infer tools/call when amount/reason present
    if not method:
        if "amount" in evt or "reason" in evt:
            return {"jsonrpc": "2.0", "id": None}, "tools/call", evt
        # unknown
        return {"jsonrpc": "2.0", "id": None}, None, {}

    params = _try_json(params)
    if params is None:
        params = {}
    if not isinstance(params, dict):
        params = {}
    return evt, method, params

def _get_workload_access_token():
    """
    Calls whatever operation name your boto3 exposes.
    We try a few likely shapes to avoid SDK drift.
    """
    if not WORKLOAD_NAME:
        raise RuntimeError("WORKLOAD_NAME env var not set")

    # Try common method names (SDKs sometimes differ)
    candidates = [
        "get_workload_access_token",
        "getWorkloadAccessToken",
    ]
    last_err = None
    for fn in candidates:
        if hasattr(dp, fn):
            try:
                # Most common request shape:
                # get_workload_access_token(workloadIdentityName=..., )
                return getattr(dp, fn)(workloadIdentityName=WORKLOAD_NAME)
            except TypeError:
                # Alternate request shapes if needed
                try:
                    return getattr(dp, fn)(workloadIdentityIdentifier=WORKLOAD_NAME)
                except Exception as e:
                    last_err = e
            except Exception as e:
                last_err = e

    raise RuntimeError(f"Could not call workload access token API via boto3. Last error: {last_err}")

def _extract_token(token_resp: dict) -> str:
    # Try common response keys
    for k in ["workloadIdentityToken", "token", "accessToken"]:
        if isinstance(token_resp, dict) and token_resp.get(k):
            return token_resp[k]
    # Sometimes nested
    if isinstance(token_resp, dict):
        for v in token_resp.values():
            if isinstance(v, dict):
                for k in ["workloadIdentityToken", "token", "accessToken"]:
                    if v.get(k):
                        return v[k]
    raise RuntimeError(f"Could not find token in response: {token_resp}")

def _get_resource_api_key(workload_token: str) -> str:
    """
    get_resource_api_key expects:
      - workloadIdentityToken
      - resourceCredentialProviderName
    """
    if not APIKEY_PROVIDER_NAME:
        raise RuntimeError("APIKEY_PROVIDER_NAME env var not set")

    # method name you saw in your notebook output
    if not hasattr(dp, "get_resource_api_key"):
        raise RuntimeError("boto3 client does not have get_resource_api_key()")

    resp = dp.get_resource_api_key(
        workloadIdentityToken=workload_token,
        resourceCredentialProviderName=APIKEY_PROVIDER_NAME
    )

    # Try response keys
    for k in ["apiKey", "value", "secret", "apiKeyValue"]:
        if resp.get(k):
            return resp[k]
    # Sometimes nested
    for v in resp.values():
        if isinstance(v, dict):
            for k in ["apiKey", "value", "secret", "apiKeyValue"]:
                if v.get(k):
                    return v[k]

    raise RuntimeError(f"Could not find API key value in get_resource_api_key response: {resp}")

def lambda_handler(event, context):
    print("=== RAW EVENT ===")
    print(_j(event))

    req, method, params = _extract_req(event)

    print("=== PARSED ===")
    print("method:", method)
    print("params:", _j(params))

    # tools/list
    if method == "tools/list":
        return _resp(req, result={
            "tools": [
                {
                    "name": "process_refund",
                    "description": "Process a refund request (demonstrates AgentCore Identity token + apiKey retrieval)",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "amount": {"type": "integer", "description": "Refund amount"},
                            "reason": {"type": "string", "description": "Reason for refund"}
                        },
                        "required": ["amount", "reason"]
                    }
                }
            ]
        })

    # tools/call
    if method == "tools/call":
        # Accept both MCP-style params and flattened
        tool_name = params.get("name") or params.get("toolName") or None
        args = params.get("arguments") or params.get("input") or params

        if not isinstance(args, dict):
            args = {}

        amount = args.get("amount")
        reason = args.get("reason")

        # If caller didnâ€™t include tool name (common in flattened events), assume process_refund
        if not tool_name:
            tool_name = "process_refund"

        if tool_name != "process_refund":
            return _resp(req, error={"code": -32601, "message": f"Unknown tool: {tool_name}"})

        if amount is None or reason is None:
            return _resp(req, error={"code": -32602, "message": "Missing required fields: amount, reason"})

        try:
            token_resp = _get_workload_access_token()
            workload_token = _extract_token(token_resp)

            api_key_value = _get_resource_api_key(workload_token)

            # Return a masked preview so you can prove it worked without leaking full secret
            masked = api_key_value[:3] + "***" + api_key_value[-3:] if len(api_key_value) >= 8 else "***"

            return _resp(req, result={
                "content": [
                    {
                        "type": "text",
                        "text": _j({
                            "status": "OK",
                            "amount": amount,
                            "reason": reason,
                            "identity": {
                                "workloadName": WORKLOAD_NAME,
                                "providerName": APIKEY_PROVIDER_NAME,
                                "apiKeyMasked": masked
                            },
                            "message": "Refund processed + AgentCore Identity token retrieved + API key fetched"
                        })
                    }
                ]
            })

        except Exception as e:
            return _resp(req, error={"code": -32000, "message": f"Identity/external call failed: {str(e)}"})

    return _resp(req, error={"code": -32601, "message": f"Unknown method: {method}"})
