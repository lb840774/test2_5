import json
import os

def _j(obj):
    return json.dumps(obj, default=str)

def _try_json(x):
    if isinstance(x, str):
        try:
            return json.loads(x)
        except Exception:
            return x
    return x

def _resp(req, result=None, error=None):
    # Return JSON-RPC style response if possible; otherwise still return same shape
    return {
        "jsonrpc": req.get("jsonrpc", "2.0") if isinstance(req, dict) else "2.0",
        "id": req.get("id") if isinstance(req, dict) else None,
        **({"result": result} if error is None else {"error": error})
    }

def _extract_method_and_params(event):
    """
    Event can arrive as:
    1) {"jsonrpc":"2.0","id":...,"method":"tools/call","params":{...}}
    2) {"method":"tools/call","params":{...}}
    3) {"params":{...}} (rare)
    4) already the params dict itself (rare) -> {"amount":25,"reason":"x"}
    """
    evt = _try_json(event)

    if not isinstance(evt, dict):
        return {}, None, {}

    method = evt.get("method")
    params = evt.get("params")

    # Sometimes params is a JSON string
    params = _try_json(params)

    # If params is missing but event looks like params itself
    if params is None and ("amount" in evt or "reason" in evt or "name" in evt or "arguments" in evt or "input" in evt):
        params = evt

    if params is None:
        params = {}

    if not isinstance(params, dict):
        params = {}

    return evt, method, params

def _extract_tool_name(params):
    # Common shapes:
    # params = {"name": "...", "arguments": {...}}
    # params = {"tool": {"name": "..."}, "arguments": {...}}
    name = params.get("name")

    tool = params.get("tool")
    if not name and isinstance(tool, dict):
        name = tool.get("name")

    # Some clients might put toolName
    if not name:
        name = params.get("toolName")

    return name

def _extract_tool_input(params):
    # Prefer arguments; fallback to input
    arguments = params.get("arguments")
    if arguments is None:
        arguments = params.get("input")

    arguments = _try_json(arguments)

    if arguments is None:
        arguments = {}

    if not isinstance(arguments, dict):
        arguments = {}

    return arguments

def _is_refund_tool(name: str) -> bool:
    if not name:
        return False
    return name == "process_refund" or name.endswith("__process_refund")

def lambda_handler(event, context):
    print("=== RAW EVENT ===")
    print(_j(event))

    req, method, params = _extract_method_and_params(event)

    print("=== PARSED ===")
    print("method:", method)
    print("params:", _j(params))

    # tools/list
    if method == "tools/list":
        return _resp(req, result={
            "tools": [
                {
                    "name": "process_refund",
                    "description": "Process a refund request",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "amount": {"type": "integer", "description": "Refund amount"},
                            "reason": {"type": "string", "description": "Reason for refund"}
                        },
                        "required": ["amount", "reason"]
                    }
                }
            ]
        })

    # tools/call
    if method == "tools/call":
        tool_name = _extract_tool_name(params)
        tool_input = _extract_tool_input(params)

        print("tool_name:", tool_name)
        print("tool_input:", _j(tool_input))

        # If gateway/client stripped name, but we only have one tool, assume refund tool
        if not tool_name:
            # This matches your current error case: params becomes {"amount":25,"reason":"..."}
            if "amount" in params or "reason" in params:
                tool_input = {**params}
                tool_name = "process_refund"

        if not _is_refund_tool(tool_name):
            return _resp(req, error={"code": -32601, "message": f"Unknown tool: {tool_name}"})

        amount = tool_input.get("amount")
        reason = tool_input.get("reason")

        if amount is None or reason is None:
            return _resp(req, error={
                "code": -32602,
                "message": f"Missing required fields: amount={amount}, reason={reason}",
                "seen": {"tool_name": tool_name, "tool_input": tool_input, "params": params}
            })

        return _resp(req, result={
            "content": [
                {
                    "type": "text",
                    "text": json.dumps({
                        "status": "OK",
                        "amount": amount,
                        "reason": reason,
                        "message": "Refund processed"
                    })
                }
            ]
        })

    # anything else
    return _resp(req if isinstance(req, dict) else {}, error={"code": -32601, "message": f"Unknown method: {method}"})
