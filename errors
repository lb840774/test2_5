import json

def _j(obj):
    return json.dumps(obj, default=str)

def _as_dict(x):
    if isinstance(x, dict):
        return x
    if isinstance(x, str):
        s = x.strip()
        if not s:
            return {}
        try:
            return json.loads(s)
        except Exception:
            return {}
    return {}

def _dig(d, keys):
    cur = d
    for k in keys:
        if not isinstance(cur, dict) or k not in cur:
            return None
        cur = cur[k]
    return cur

def _mcp_ok(result_id, result_obj):
    # JSON-RPC style
    return {"jsonrpc": "2.0", "id": result_id, "result": result_obj}

def _mcp_err(result_id, code, msg, extra=None):
    e = {"code": code, "message": msg}
    if extra is not None:
        e["data"] = extra
    return {"jsonrpc": "2.0", "id": result_id, "error": e}

def _tool_output_text(text, is_error=False):
    # Non JSON-RPC "content" style
    return {"isError": bool(is_error), "content": [{"type": "text", "text": text}]}

def lambda_handler(event, context):
    # Always log what we got (view in CloudWatch Logs)
    print("RAW EVENT:", _j(event))

    # Try unwrap common wrappers
    evt = event if isinstance(event, dict) else {}
    body = _as_dict(evt.get("body")) if "body" in evt else None
    req = body if isinstance(body, dict) and body else evt

    # Sometimes gateway nests under detail/input/payload
    for k in ("detail", "payload", "request", "input", "data"):
        cand = _as_dict(req.get(k)) if isinstance(req, dict) else {}
        if cand:
            req = cand
            break

    print("NORMALIZED REQ:", _j(req))

    # --- PATH A: JSON-RPC MCP ---
    if isinstance(req, dict) and ("jsonrpc" in req or "method" in req):
        method = req.get("method")
        params = req.get("params") or {}
        rid = req.get("id")

        if method == "tools/list":
            return _mcp_ok(rid, {
                "tools": [{
                    "name": "process_refund",
                    "description": "Process a refund request",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "amount": {"type": "integer"},
                            "reason": {"type": "string"}
                        },
                        "required": ["amount", "reason"]
                    }
                }]
            })

        if method == "tools/call":
            name = params.get("name")
            payload = params.get("arguments")
            if not isinstance(payload, dict):
                payload = params.get("input")
            if not isinstance(payload, dict):
                payload = {}

            if not name:
                return _mcp_err(rid, -32602, "Missing params.name", extra={"params": params})

            # Allow gateway-prefixed tool name
            if not (name == "process_refund" or name.endswith("__process_refund")):
                return _mcp_err(rid, -32601, f"Unknown tool: {name}")

            amount = payload.get("amount")
            reason = payload.get("reason")
            if amount is None or reason is None:
                return _mcp_err(rid, -32602, "Missing required fields: amount, reason", extra={"payload": payload})

            return _mcp_ok(rid, {
                "content": [{"type": "text", "text": _j({"status": "OK", "amount": amount, "reason": reason})}]
            })

        return _mcp_err(rid, -32601, f"Unknown method: {method}", extra={"req": req})

    # --- PATH B: Non JSON-RPC gateway invoke (inline schema style) ---
    # Try locate tool name + input in several common places
    tool_name = (
        req.get("name")
        or req.get("toolName")
        or _dig(req, ["tool", "name"])
        or _dig(req, ["tool", "toolName"])
    )

    tool_input = (
        req.get("arguments")
        or req.get("input")
        or req.get("parameters")
        or _dig(req, ["tool", "input"])
        or _dig(req, ["tool", "arguments"])
        or {}
    )
    tool_input = tool_input if isinstance(tool_input, dict) else _as_dict(tool_input)

    print("NON-RPC tool_name:", tool_name)
    print("NON-RPC tool_input:", _j(tool_input))

    if not tool_name:
        return _tool_output_text(_j({"error": "Missing tool name", "req": req}), is_error=True)

    if not (tool_name == "process_refund" or str(tool_name).endswith("__process_refund")):
        return _tool_output_text(_j({"error": f"Unknown tool: {tool_name}"}), is_error=True)

    amount = tool_input.get("amount")
    reason = tool_input.get("reason")
    if amount is None or reason is None:
        return _tool_output_text(_j({"error": "Missing required fields", "required": ["amount","reason"], "got": tool_input}), is_error=True)

    return _tool_output_text(_j({"status": "OK", "amount": amount, "reason": reason}), is_error=False)
